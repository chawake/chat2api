/**
 * ===================================================================================
 * WORKER ROUTER CON MANEJO DE GENERACIÓN DE IMÁGENES (VERSIÓN ROBUSTA)
 * ===================================================================================
 */

// ===================================================================================
// UTILIDADES (ITTY-ROUTER MINIFICADO + PARSERS)
// ===================================================================================
var e = (e2 = {}) => {
  const { origin: o = "*", credentials: s = false, allowMethods: c = "*", allowHeaders: r2, exposeHeaders: n, maxAge: t } = e2, a = (e3) => {
    const c2 = e3?.headers.get("origin");
    return true === o ? c2 : o instanceof RegExp ? o.test(c2) ? c2 : void 0 : Array.isArray(o) ? o.includes(c2) ? c2 : void 0 : o instanceof Function ? o(c2) : "*" == o && s ? c2 : o;
  }, l = (e3, o2) => {
    for (const [s2, c2] of Object.entries(o2)) c2 && e3.headers.append(s2, c2);
    return e3;
  };
  return {
    corsify: (response, request) => {
      if (!response || response.headers?.get("access-control-allow-origin") || response.status === 101) {
        return response;
      }
      const newHeaders = new Headers(response.headers);
      const origin = a(request);
      if (origin) newHeaders.set("access-control-allow-origin", origin);
      if (s) newHeaders.set("access-control-allow-credentials", "true");
      return new Response(response.body, { status: response.status, statusText: response.statusText, headers: newHeaders });
    },
    preflight: (e3) => {
      if ("OPTIONS" == e3.method) {
        return l(new Response(null, { status: 204 }), {
          "access-control-allow-origin": a(e3),
          "access-control-allow-methods": c?.join?.(",") ?? c,
          "access-control-expose-headers": n?.join?.(",") ?? n,
          "access-control-allow-headers": r2?.join?.(",") ?? r2 ?? e3.headers.get("access-control-request-headers"),
          "access-control-max-age": t,
          "access-control-allow-credentials": s
        });
      }
    }
  };
};

var r = ({ base: r2 = "", routes: e2 = [], ...a } = {}) => ({
  __proto__: new Proxy({}, {
    get: (a2, t, o, c) => (a3, ...l) => e2.push([
      t.toUpperCase?.(),
      RegExp(`^${(c = (r2 + a3).replace(/\/+(\/|$)/g, "$1")).replace(/(\/?\.?):(\w+)\+/g, "($1(?<$2>*))").replace(/(\/?\.?):(\w+)/g, "($1(?<$2>[^$1/]+?))").replace(/\./g, "\\.").replace(/(\/?)\*/g, "($1.*)?")}/*$`),
      l, c
    ]) && o
  }),
  routes: e2,
  ...a,
  async fetch(r3, ...t) {
    let o, c, l = new URL(r3.url), p = r3.query = { __proto__: null };
    for (let [r4, e3] of l.searchParams) p[r4] = p[r4] ? [].concat(p[r4], e3) : e3;
    r: try {
      for (let e3 of a.before || []) if (null != (o = await e3(r3.proxy ?? r3, ...t))) break r;
      e: for (let [a2, p2, f, h] of e2) if ((a2 == r3.method || "ALL" == a2) && (c = l.pathname.match(p2))) {
        r3.params = c.groups || {}, r3.route = h;
        for (let e3 of f) if (null != (o = await e3(r3.proxy ?? r3, ...t))) break e;
      }
    } catch (e3) {
      if (!a.catch) throw e3;
      o = await a.catch(e3, r3.proxy ?? r3, ...t);
    }
    try {
      for (let e3 of a.finally || []) o = await e3(o, r3.proxy ?? r3, ...t) ?? o;
    } catch (e3) {
      if (!a.catch) throw e3;
      o = await a.catch(e3, r3.proxy ?? r3, ...t);
    }
    return o;
  }
});

// ===================================================================================
// CONFIGURACIÓN CENTRAL
// ===================================================================================
const MODEL_ROUTING_MAP = {
  "claude-3.5-haiku-latest":{ targetModel: "claude-3-haiku", proxy: "OPEN_PROXY" },
  "claude-3-7-sonnet-latest":{ targetModel: "claude-3-sonnet", proxy: "OPEN_PROXY" },
  "claude-sonnet-4-20250514":{ targetModel: "claude-sonnet-4", proxy: "OPEN_PROXY" },
  "gpt-3.5-turbo": { targetModel: "gemini-2.0-flash", proxy: "GEMINI_DEFAULT" },
  "gpt-4o": { targetModel: "gpt-5", proxy: "OPEN_PROXY" },
  "gpt-4o-mini": { targetModel: "gpt-5", proxy: "OPEN_PROXY" },
  "gpt-4.1-nano": { targetModel: "gpt-5", proxy: "OPEN_PROXY" },
  "gpt-4.1-mini":{ targetModel: "gpt-5", proxy: "OPEN_PROXY" },
  "o3-mini": { targetModel: "o3-mini", proxy: "OPEN_PROXY" },
  "o4-mini": { targetModel: "o3-mini", proxy: "OPEN_PROXY" },
  "o1": { targetModel: "o1", proxy: "OPEN_PROXY" },
  "gpt-5": { targetModel: "gpt-5", proxy: "OPEN_PROXY" },
  "gpt-5-chat-latest": { targetModel: "gpt-5", proxy: "OPEN_PROXY" },
  "gpt-5-mini": { targetModel: "gpt-5", proxy: "OPEN_PROXY" },
  "gpt-5-nano": { targetModel: "gpt-5", proxy: "OPEN_PROXY" },
  "gpt-5-thinking": { targetModel: "gpt-5-thinking", proxy: "OPEN_PROXY" },
  "gpt-image-1": { targetModel: "gpt-image-1", proxy: "OPEN_PROXY", type: "image" },
  "dall-e-3": { targetModel: "dall-e-3", proxy: "OPEN_PROXY", type: "image" },
  "g-687a97367460819180382fe7012bf026": { targetModel: "g-687a97367460819180382fe7012bf026@gpt-5-thinking", proxy: "OPEN_PROXY"},
};

// ===================================================================================
// HELPERS (Base64 & SSE)
// ===================================================================================
function arrayBufferToBase64(buffer) {
  let binary = '';
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}

function parseBase64(base64) {
  if (!base64.startsWith("data:")) return { text: "" };
  const [m, data] = base64.split(",");
  const mimeType = m.match(/:(?<mime>.*?);/)?.groups?.mime ?? "img/png";
  return { inlineData: { mimeType, data } };
}

function openAiMessageToGeminiMessage(messages) {
  return messages.flatMap(({ role, content }) => {
    if (role === "system") {
      return [
        { role: "user", parts: typeof content !== "string" ? content : [{ text: content }] },
        { role: "model", parts: [{ text: "Understood." }] }
      ];
    }
    const parts = content == null || typeof content === "string" ?
      [{ text: content?.toString() ?? "" }] :
      content.map((item) => {
        if (item.type === "text") return { text: item.text };
        if (item.type === "image_url") return parseBase64(item.image_url.url);
        return { text: "" };
      });
    return [{ role: "user" === role ? "user" : "model", parts }];
  });
}

function genModel(targetModel, req) {
  const generateContentRequest = {
    contents: openAiMessageToGeminiMessage(req.messages),
    generationConfig: {
      maxOutputTokens: req.max_completion_tokens ?? void 0,
      temperature: req.temperature ?? void 0,
      topP: req.top_p ?? void 0,
    },
    safetySettings: ["HARM_CATEGORY_HATE_SPEECH", "HARM_CATEGORY_SEXUALLY_EXPLICIT", "HARM_CATEGORY_DANGEROUS_CONTENT", "HARM_CATEGORY_HARASSMENT"]
      .map((category) => ({ category, threshold: "BLOCK_NONE" }))
  };
  return [targetModel, generateContentRequest];
}

// SSE Parser simplificado
var ParseError=class extends Error{constructor(e,t){super(e),this.name="ParseError",this.type=t.type,this.field=t.field,this.value=t.value,this.line=t.line}};function noop(e){}function createParser(e){if("function"==typeof e)throw new TypeError("`callbacks` must be an object");const{onEvent:t=noop,onError:r=noop,onRetry:n=noop,onComment:s}=e;let i="",o=!0,a,l="",u="";function c(e){const t=o?e.replace(/^\xEF\xBB\xBF/,""):e,[r,n]=h(`${i}${t}`);for(const e of r)d(e);i=n,o=!1}function d(e){if(""===e){f();return}if(e.startsWith(":")){s&&s(e.slice(e.startsWith(": ")?2:1));return}const t=e.indexOf(":");if(-1!==t){const r=e.slice(0,t),n=e[t+1]===" "?2:1,s=e.slice(t+n);p(r,s,e);return}p(e,"",e)}function p(e,t,n){switch(e){case"event":u=t;break;case"data":l=`${l}${t}\n`;break;case"id":a=t.includes("\0")?void 0:t;break;case"retry":/^\d+$/.test(t)?n(parseInt(t,10)):r(new ParseError(`Invalid \`retry\` value: "${t}"`,{type:"invalid-retry",value:t,line:n}));break;default:r(new ParseError(`Unknown field "${e.length>20?`${e.slice(0,20)}\u2026`:e}"`,{type:"unknown-field",field:e,value:t,line:n}))}}function f(){l.length>0&&t({id:a,event:u||void 0,data:l.endsWith("\n")?l.slice(0,-1):l}),a=void 0,l="",u=""}return{feed:c,reset:function(e={}){i&&e.consume&&d(i),o=!0,a=void 0,l="",u="",i=""}}}function h(e){const t=[];let r="",n=0;for(;n<e.length;){const s=e.indexOf("\r",n),i=e.indexOf("\n",n);let o=-1;if(s!==-1&&i!==-1?o=Math.min(s,i):s!==-1?o=s:i!==-1&&(o=i),o===-1){r=e.slice(n);break}else{const a=e.slice(n,o);t.push(a),n=o+1,e[n-1]==="\r"&&e[n]==="\n"&&n++}}return[t,r]}var EventSourceParserStream=class extends TransformStream{constructor({onError:e,onRetry:t,onComment:r}={}){let n;super({start(s){n=createParser({onEvent:e=>{s.enqueue(e)},onError(t){"terminate"===e?s.error(t):"function"==typeof e&&e(t)},onRetry:t,onComment:r})},transform(e){n.feed(e)}})}};

// ===================================================================================
// HANDLERS DE GEMINI
// ===================================================================================
function resultHelper(response) { 
  if (response.candidates && response.candidates.length > 0) return response.candidates[0].content?.parts?.[0]?.text || ""; 
  return ""; 
}

async function* streamGenerateContent(targetModel, params, requestOptions, env) {
  const baseUrl = env.GEMINI_DEFAULT;
  const apiKey = env.GEMINI_DEFAULT_KEY;
  if (!baseUrl || !apiKey) throw new Error(`Faltan credenciales de Gemini (GEMINI_DEFAULT).`);
  
  const url = new URL(`${baseUrl}/v1beta/models/${targetModel}:streamGenerateContent`);
  url.searchParams.append("key", apiKey);
  url.searchParams.append("alt", "sse");
  
  const response = await fetch(url.toString(), { ...requestOptions, method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(params) });
  if (!response.ok) throw new Error(`Gemini API Error: ${response.status} ${await response.text()}`);
  
  const body = response.body;
  if (!body) return;
  for await (const event of body.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream())) {
    if(event.data && event.data.trim() !== '') {
        try {
            const responseJson = JSON.parse(event.data);
            yield responseJson;
        } catch (e) { console.error("SSE Parse Error", e); }
    }
  }
}

async function handleGeminiRequest(targetModel, reqBody, env) {
  const [, geminiReq] = genModel(targetModel, reqBody);
  try {
    const url = new URL(`${env.GEMINI_DEFAULT}/v1beta/models/${targetModel}:generateContent`);
    url.searchParams.append("key", env.GEMINI_DEFAULT_KEY);
    const response = await fetch(url.toString(), { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(geminiReq) });
    if (!response.ok) throw new Error(`Gemini API Error: ${response.status} ${await response.text()}`);
    const responseData = await response.json();
    const text = resultHelper(responseData);
    return new Response(JSON.stringify({ id: "chatcmpl-" + crypto.randomUUID(), object: "chat.completion", created: Math.floor(Date.now() / 1000), model: reqBody.model, choices: [{ index: 0, message: { role: "assistant", content: text }, finish_reason: "stop" }] }), { headers: { "Content-Type": "application/json" } });
  } catch (err) {
    return new Response(JSON.stringify({ error: err.message }), { status: 500 });
  }
}

async function handleGeminiStreamingRequest(targetModel, reqBody, env) {
    const [, geminiReq] = genModel(targetModel, reqBody);
    const encoder = new TextEncoder();
    const readableStream = new ReadableStream({
        async start(controller) {
            try {
                for await (const chunk of streamGenerateContent(targetModel, geminiReq, {}, env)) {
                    const content = resultHelper(chunk);
                    if (content) {
                        const streamChunk = { id: "chatcmpl-" + crypto.randomUUID(), object: "chat.completion.chunk", created: Math.floor(Date.now() / 1000), model: reqBody.model, choices: [{ index: 0, delta: { content: content }, finish_reason: null }] };
                        controller.enqueue(encoder.encode(`data: ${JSON.stringify(streamChunk)}\n\n`));
                    }
                }
            } catch (err) {
                controller.enqueue(encoder.encode(`data: ${JSON.stringify({ error: { message: err.message } })}\n\n`));
            } finally {
                controller.enqueue(encoder.encode(`data: ${JSON.stringify({ id: "chatcmpl-"+crypto.randomUUID(), object: "chat.completion.chunk", created: Math.floor(Date.now()/1000), model: reqBody.model, choices: [{ index: 0, delta: {}, finish_reason: "stop" }] })}\n\n`));
                controller.enqueue(encoder.encode('data: [DONE]\n\n'));
                controller.close();
            }
        }
    });
    return new Response(readableStream, { headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" } });
}

// ===================================================================================
// HANDLER DE PROXY TEXTO (OPENAI)
// ===================================================================================
async function handleWorkerAuthenticatedProxy(targetProxyUrl, apiKey, originalRequest, requestBody) {
  if (!targetProxyUrl || !apiKey) return new Response('Configuración de Proxy Faltante', { status: 500 });
  
  const originalUrl = new URL(originalRequest.url);
  const finalUrl = `${targetProxyUrl.replace(/\/$/, "")}${originalUrl.pathname}`;
  
  // Inyección System Prompt
  if (requestBody.model === 'gpt-5-nano') {
      const nanoPrompt = { role: "system", content: "INSTRUCCIÓN CRÍTICA: Solo texto plano. No imágenes, no enlaces. Eres una IA de solo texto." };
      requestBody.messages = requestBody.messages || [];
      const sys = requestBody.messages.find(m => m.role === 'system');
      if (sys) sys.content += "\n\n" + nanoPrompt.content; else requestBody.messages.unshift(nanoPrompt);
  }

  const forwardedHeaders = new Headers();
  for (const [k, v] of originalRequest.headers.entries()) {
    const lk = k.toLowerCase();
    if (lk !== 'host' && lk !== 'authorization' && !lk.startsWith('cf-')) forwardedHeaders.append(k, v);
  }
  forwardedHeaders.set('Authorization', `Bearer ${apiKey}`);

  return fetch(finalUrl, {
    method: originalRequest.method,
    headers: forwardedHeaders,
    body: JSON.stringify(requestBody),
    redirect: 'follow'
  });
}

function handleOpenAIRequest(targetProxyUrl, originalRequest, requestBody) {
  if (!targetProxyUrl) return new Response('OPENAI_ENDPOINT no configurado', { status: 500 });
  const originalUrl = new URL(originalRequest.url);
  const finalUrl = `${targetProxyUrl.replace(/\/$/, "")}${originalUrl.pathname.replace(/^\/v1/, '')}`;
  const headers = new Headers(originalRequest.headers);
  headers.delete('Host'); // Eliminamos Host por seguridad
  return fetch(finalUrl, { method: originalRequest.method, headers: headers, body: JSON.stringify(requestBody) });
}

// ===================================================================================
// HANDLER DE IMÁGENES (CORREGIDO Y BLINDADO)
// ===================================================================================
async function handleImageGenerationProxy(rawReq, env) {
  try {
      let imageRequestBody;
      try {
        imageRequestBody = await rawReq.json();
      } catch (e) {
        return new Response(JSON.stringify({ 
            error: "Invalid JSON in Request Body", 
            details: "El JSON enviado tiene errores de sintaxis (probablemente falta un ':' o una comilla).",
            js_error: e.message 
        }), { status: 400, headers: { 'Content-Type': 'application/json' } });
      }

      const modelName = imageRequestBody.model;
      const route = MODEL_ROUTING_MAP[modelName];
      if (!route || route.proxy !== 'OPEN_PROXY') {
          return new Response(JSON.stringify({ error: `Modelo ${modelName} no válido para imágenes.` }), { status: 400 });
      }

      const proxyUrl = env.OPEN_PROXY;     
      const apiKey = env.OPEN_PROXY_KEY;   
      if (!proxyUrl || !apiKey) throw new Error("Faltan variables OPEN_PROXY/KEY.");

      let detailedPrompt = `Generate a high-quality image of: ${imageRequestBody.prompt}.`;
      if (imageRequestBody.model) detailedPrompt += ` Model: ${imageRequestBody.model}.`;
      if (imageRequestBody.size) detailedPrompt += ` Size: ${imageRequestBody.size}.`;
      detailedPrompt += ` Return the direct image URL.`;

      const chatRequestBody = {
          model: imageRequestBody.model,
          messages: [{ role: "user", content: detailedPrompt }],
          stream: false
      };

      const proxyBaseUrl = proxyUrl.replace(/\/$/, ""); 
      const genRequest = new Request(`${proxyBaseUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`,
            'User-Agent': 'JapiGateway-Worker/1.0'
          },
          body: JSON.stringify(chatRequestBody)
      });

      const genResponse = await fetch(genRequest);
      let genData;
      let rawText = "";
      try {
        rawText = await genResponse.text();
        if (!genResponse.ok) {
            return new Response(JSON.stringify({ error: "Error Upstream", status: genResponse.status, body: rawText }), { status: genResponse.status });
        }
        genData = JSON.parse(rawText);
      } catch (e) {
        return new Response(JSON.stringify({ 
            error: "Invalid JSON from Upstream Proxy", 
            message: "El wrapper devolvió algo que no es JSON válido.",
            raw_response_preview: rawText.substring(0, 500),
            js_error: e.message
        }), { status: 502, headers: { 'Content-Type': 'application/json' } });
      }

      const textContent = genData.choices?.[0]?.message?.content || "";

      let rawImageUrl = "";
      let toolPayload = null;
      const mdMatch = textContent.match(/!\[.*?\]\((.*?)\)/);
      const urlMatch = textContent.match(/https?:\/\/[^\s)"']+/);
      const toolMatch = textContent.match(/```image_creator\s*({[\s\S]*?})\s*```/);

      if (mdMatch && mdMatch[1]) {
          rawImageUrl = mdMatch[1];
      } else if (urlMatch && urlMatch[0]) {
          rawImageUrl = urlMatch[0];
      } else if (toolMatch && toolMatch[1]) {
          try {
              toolPayload = JSON.parse(toolMatch[1]);
          } catch (err) {
              console.error("Error parseando bloque image_creator", err);
          }
      }

      if (!rawImageUrl && !toolPayload) {
          return new Response(JSON.stringify({
              error: "Image generation proxy",
              message: "No URL ni bloque image_creator en la respuesta upstream.",
              snippet: textContent.substring(0, 200)
          }), { status: 502, headers: { 'Content-Type': 'application/json' } });
      }

      if (toolPayload) {
          const promptForImage = toolPayload.prompt || imageRequestBody.prompt;
          const sizeForImage = toolPayload.size || imageRequestBody.size || "1024x1024";

          const upstreamResp = await fetch(`${proxyBaseUrl}/v1/images/generations`, {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${apiKey}`,
                  'User-Agent': 'JapiGateway-Worker/1.0'
              },
              body: JSON.stringify({
                  prompt: promptForImage,
                  size: sizeForImage,
                  response_format: "b64_json",
                  n: 1
              })
          });

          const upstreamJson = await upstreamResp.json().catch(() => ({}));
          if (!upstreamResp.ok || !upstreamJson?.data?.length) {
              return new Response(JSON.stringify({
                  error: "Image upstream error",
                  status: upstreamResp.status,
                  body: upstreamJson
              }), { status: upstreamResp.status || 502, headers: { 'Content-Type': 'application/json' } });
          }

          return new Response(JSON.stringify({
              created: upstreamJson.created || Math.floor(Date.now() / 1000),
              data: upstreamJson.data
          }), { headers: { 'Content-Type': 'application/json' } });
      }

      let targetUrlStr = rawImageUrl;
      try {
          if (rawImageUrl.startsWith('http')) {
              const parsedUrl = new URL(rawImageUrl);
              const pathAndQuery = parsedUrl.pathname + parsedUrl.search;
              targetUrlStr = `${proxyBaseUrl}${pathAndQuery}`;
          } else {
              if (!rawImageUrl.startsWith('/')) rawImageUrl = '/' + rawImageUrl;
              targetUrlStr = `${proxyBaseUrl}${rawImageUrl}`;
          }
      } catch (e) { console.error("Error reescribiendo URL", e); }

      console.log(`Descargando túnel: ${targetUrlStr}`);

      const imageResponse = await fetch(targetUrlStr, { 
          method: 'GET', 
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
            'Accept': '*/*',
            'Authorization': `Bearer ${apiKey}`
          } 
      });

      if (!imageResponse.ok) {
         const failText = await imageResponse.text();
         throw new Error(`Fallo descarga (${imageResponse.status}) en ${targetUrlStr}: ${failText}`);
      }

      const arrayBuffer = await imageResponse.arrayBuffer();
      const b64 = arrayBufferToBase64(arrayBuffer);

      return new Response(JSON.stringify({
          created: Math.floor(Date.now() / 1000),
          data: [{ b64_json: b64 }]
      }), { headers: { 'Content-Type': 'application/json' } });

  } catch (e) {
      return new Response(JSON.stringify({ 
          error: "Worker Logic Exception", 
          message: e.message,
          stack: e.stack
      }), { status: 500, headers: {'Content-Type': 'application/json'} });
  }
}

// ===================================================================================
// ROUTER PRINCIPAL
// ===================================================================================
async function chatProxyHandler(rawReq, env) {
  const reqClone = rawReq.clone();
  let reqBody;
  try {
      reqBody = await reqClone.json();
  } catch (e) {
      return new Response(JSON.stringify({ error: "Invalid JSON Body" }), { status: 400 });
  }
  
  const modelName = reqBody.model;
  const route = MODEL_ROUTING_MAP[modelName];

  if (route) {
    if (route.proxy === 'GEMINI_DEFAULT') {
      return reqBody.stream ? handleGeminiStreamingRequest(route.targetModel, reqBody, env) : handleGeminiRequest(route.targetModel, reqBody, env);
    }
    if (route.proxy === 'OPEN_PROXY') {
        const routeInfo = MODEL_ROUTING_MAP[reqBody.model];
        if (routeInfo && routeInfo.type === 'image') {
            return new Response(JSON.stringify({ 
                error: "Usa el endpoint de imágenes /v1/images/generations",
                choices: [{ message: { content: "Por favor usa /v1/images/generations" } }] 
            }), { headers: { "Content-Type": "application/json" } });
        }
        return handleWorkerAuthenticatedProxy(env.OPEN_PROXY, env.OPEN_PROXY_KEY, rawReq, reqBody);
    }
  }
  return handleOpenAIRequest(env.OPENAI_ENDPOINT, rawReq, reqBody);
}

const { preflight, corsify } = e({ allowHeaders: "*" });
const app = r();

app.all("*", preflight);
app.post("/v1/images/generations", (req, env) => handleImageGenerationProxy(req, env));
app.post("/v1/chat/completions", (req, env) => chatProxyHandler(req, env));
app.all("*", () => new Response("Ruta no encontrada", { status: 404 }));

export default {
  fetch: (request, env, ctx) => app.fetch(request, env, ctx).then(corsify)
};